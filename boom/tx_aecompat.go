package boom

import (
	"reflect"

	"go.mercari.io/datastore"
)

// IMPORTANT NOTICE: You should use *boom.Transaction.

var _ AECompatibleOperations = &Boom{}
var _ AECompatibleOperations = &AECompatibleTransaction{}

// AECompatibleOperations represents Transaction, if not, both common operations.
// In AppEngine Datastore transactions immediately return Key.
// In order to realize this, this wrapper internally performs AllocateID when it is required.
//
// This is for migrating existing code and should not be used if possible.
type AECompatibleOperations interface {
	Kind(src interface{}) string
	Key(src interface{}) datastore.Key
	KeyError(src interface{}) (datastore.Key, error)
	Get(dst interface{}) error
	GetMulti(dst interface{}) error
	Put(src interface{}) (datastore.Key, error)
	PutMulti(src interface{}) ([]datastore.Key, error)
	Delete(src interface{}) error
	DeleteMulti(src interface{}) error
}

// ToAECompatibleTransaction converts a transaction to AECompatibleTransaction.
// AECompatibleTransaction implements AECompatibleOperations.
func ToAECompatibleTransaction(tx *Transaction) *AECompatibleTransaction {
	return &AECompatibleTransaction{bm: tx.bm, tx: tx.tx}
}

// AECompatibleTransaction implements AECompatibleOperations.
// It is useful for migration when using AppEngine Datastore,
// when using transactions or not using it with using the same code.
type AECompatibleTransaction struct {
	bm *Boom
	tx datastore.Transaction
}

// Boom object that is the source of the Batch object is returned.
func (tx *AECompatibleTransaction) Boom() *Boom {
	return tx.bm
}

// Kind retrieves kind name from struct.
func (tx *AECompatibleTransaction) Kind(src interface{}) string {
	return tx.bm.Kind(src)
}

// Key retrieves datastore key from struct without error occurred.
func (tx *AECompatibleTransaction) Key(src interface{}) datastore.Key {
	return tx.bm.Key(src)
}

// KeyError retrieves datastore key from struct with error occurred.
func (tx *AECompatibleTransaction) KeyError(src interface{}) (datastore.Key, error) {
	return tx.bm.KeyError(src)
}

// Get loads the entity stored for key into dst, which must be a struct pointer or implement PropertyLoadSaver.
// key will be extracted from dst.
//
// If there is no such entity for the key, Get returns ErrNoSuchEntity.
// The values of dst's unmatched struct fields are not modified, and matching slice-typed fields are not reset before appending to them.
// In particular, it is recommended to pass a pointer to a zero valued struct on each Get call.
func (tx *AECompatibleTransaction) Get(dst interface{}) error {
	dsts := []interface{}{dst}
	err := tx.GetMulti(dsts)
	if merr, ok := err.(datastore.MultiError); ok {
		return merr[0]
	} else if err != nil {
		return err
	}

	return nil
}

// GetMulti is a batch version of Get.
// key will be extracted from each struct of dst.
//
// dst must be a []S, []*S, []I or []P, for some struct type S, some interface type I, or some non-interface non-pointer type P such that P or *P implements PropertyLoadSaver.
// If an []I, each element must be a valid dst for Get: it must be a struct pointer or implement PropertyLoadSaver.
func (tx *AECompatibleTransaction) GetMulti(dst interface{}) error {
	keys, err := tx.bm.extractKeys(dst)
	if err != nil {
		return err
	}

	return tx.tx.GetMulti(keys, dst)
}

// Put saves the entity src into the datastore.
// key will be extract from src struct.
// src must be a struct pointer or implement PropertyLoadSaver; if a struct pointer then any unexported fields of that struct will be skipped.
// If k is an incomplete key, the returned key will be a unique key generated by the datastore,
// and inject key to src struct.
func (tx *AECompatibleTransaction) Put(src interface{}) (datastore.Key, error) {
	srcs := []interface{}{src}
	keys, err := tx.PutMulti(srcs)
	if merr, ok := err.(datastore.MultiError); ok {
		return nil, merr[0]
	} else if err != nil {
		return nil, err
	}

	return keys[0], nil
}

// PutMulti is a batch version of Put.
//
// src must satisfy the same conditions as the dst argument to GetMulti.
func (tx *AECompatibleTransaction) PutMulti(src interface{}) ([]datastore.Key, error) {
	keys, err := tx.bm.extractKeys(src)
	if err != nil {
		return nil, err
	}

	// This api should returns []datastore.Key.
	// Use AllocateIDs instead of []datastore.PendingKey.
	incompleteIndexes := make([]int, 0, len(keys))
	incompleteKeys := make([]datastore.Key, 0, len(keys))
	for idx, key := range keys {
		if key.Incomplete() {
			incompleteIndexes = append(incompleteIndexes, idx)
			incompleteKeys = append(incompleteKeys, key)
		}
	}
	incompleteKeys, err = tx.bm.AllocateIDs(incompleteKeys)
	if err != nil {
		return nil, err
	}
	for idx, inIdx := range incompleteIndexes {
		keys[inIdx] = incompleteKeys[idx]
	}

	_, err = tx.tx.PutMulti(keys, src)
	if err != nil {
		return nil, err
	}

	v := reflect.Indirect(reflect.ValueOf(src))
	for idx, key := range keys {
		err = tx.bm.setStructKey(v.Index(idx).Interface(), key)
		if err != nil {
			return nil, err
		}
	}

	return keys, nil
}

// Delete deletes the entity.
// key will be extract from src struct.
func (tx *AECompatibleTransaction) Delete(src interface{}) error {
	srcs := []interface{}{src}
	err := tx.DeleteMulti(srcs)
	if merr, ok := err.(datastore.MultiError); ok {
		return merr[0]
	} else if err != nil {
		return err
	}

	return nil
}

// DeleteMulti is a batch version of Delete.
func (tx *AECompatibleTransaction) DeleteMulti(src interface{}) error {
	keys, err := tx.bm.extractKeys(src)
	if err != nil {
		return err
	}

	return tx.tx.DeleteMulti(keys)
}

// Commit applies the enqueued operations atomically.
func (tx *AECompatibleTransaction) Commit() (datastore.Commit, error) {
	commit, err := tx.tx.Commit()
	if err != nil {
		return nil, err
	}

	return commit, nil
}

// Rollback abandons a pending transaction.
func (tx *AECompatibleTransaction) Rollback() error {
	return tx.tx.Rollback()
}
